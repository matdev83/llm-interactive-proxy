Based on my detailed analysis, here are the specific problems with Legacy app.state coupling - Direct FastAPI state manipulation:
üîç Detailed Problem Analysis
1. Direct State Mutation in Domain Layer
Location: src/core/domain/commands/set_command.py (lines 234, 322)
Issues:
Domain layer directly manipulating web framework state - violates Dependency Inversion Principle (DIP)
Tight coupling between domain logic and FastAPI framework
No abstraction layer - domain commands know about FastAPI's app.state
Runtime coupling - domain layer depends on web framework being present
Testing complexity - tests must mock context.app structure
2. Test Infrastructure Dependency on app.state
Location: src/core/app/test_builder.py (lines 142-148, 171)
Issues:
State copying anti-pattern - copying state between FastAPI apps
Tight coupling between test builder and FastAPI state structure
Runtime state management - managing state across app instances
No clear separation between application state and service state
3. Context Object Coupling
Location: src/core/services/command_processor.py (line 51)
Issues:
Inconsistent state access patterns - mixing context.state and context.app_state
No clear abstraction - service layer directly accessing state attributes
Context object doing too much - context objects shouldn't hold state
Hard to test - requires complex context object mocking
4. Security Layer State Dependencies
Location: src/core/security/middleware.py (lines 94-95)
Issues:
Security layer coupled to app.state - security middleware depends on FastAPI state
No abstraction - security logic directly accessing framework state
Configuration through state - using app.state for configuration instead of proper config injection
Testing challenges - security tests need to set up FastAPI app.state
5. Session State Access Patterns
Location: Multiple files accessing session.state.backend_config
Issues:
Mixed state models - using both domain objects and app.state
No clear state boundaries - session state accessed directly by services
Violation of encapsulation - services reaching into session state directly
üö® Architectural Violations
SOLID Principle Violations:
Single Responsibility Principle (SRP):
Domain commands are responsible for both business logic AND state management
Services handle business logic AND directly manipulate framework state
Dependency Inversion Principle (DIP):
Domain layer depends on concrete FastAPI app.state instead of abstractions
Services depend on framework-specific state instead of injected configuration
Interface Segregation Principle (ISP):
Context objects have multiple state access patterns (state, app_state)
Single interface doing too many things (business logic + state management)
Clean Architecture Violations:
Framework Independence: Domain layer should be independent of web framework
Dependency Rule: Inner layers shouldn't know about outer layers
Configuration Management: Configuration should flow inward, not be accessed outward
‚ö° Runtime and Testing Issues
Tight Coupling: Changes to FastAPI state structure break domain logic
Testing Complexity: Every test needs to set up proper app.state structure
Mock Complexity: Tests must mock both business logic AND framework state
Runtime Errors: Missing app.state attributes cause runtime failures
Configuration Scattered: Configuration split between proper config objects and app.state
üîß Recommended Solutions
Introduce Configuration Services:
Use Dependency Injection:
Create State Management Abstractions:
IApplicationState interface
IConfigurationService interface
Proper state management services
Separate Concerns:
Move state management out of domain commands
Create dedicated configuration management services
Use event-driven state updates
This legacy coupling makes the codebase fragile, hard to test, and violates fundamental architectural principles. The domain layer should be completely unaware of the web framework implementation details.